--- 
layout: post
tags: []

type: post
meta: 
  _encloseme: "1"
published: true
title: "Web Service\xE5\xAE\x9E\xE8\xB7\xB5\xE4\xB9\x8BREST vs RPC"
status: publish
category: tech
---
<span class="Apple-style-span" style="font-family: 'Times New Roman'; line-height: normal; font-size: medium; "><h1 class="title" style="text-align: center; ">Web Service实践之REST vs RPC</h1><p>本博客所有内容采用&nbsp;<a class="reference external" href="http://creativecommons.org/about/licenses/meet-the-licenses" target="_blank">Creative Commons Licenses</a>&nbsp;许可使用. 引用本内容时，请保留&nbsp;<a class="reference external" href="http://sites.google.com/site/towerjoo" target="_blank">朱涛</a>,&nbsp;<a class="reference external" href="http://www.cnblogs.com/mindsbook" target="_blank">出处</a>&nbsp;，并且&nbsp;<strong>非商业</strong>&nbsp;.</p><p>点击&nbsp;<a class="reference external" href="http://feed.feedsky.com/MindsbookTowerJoo" target="_blank">订阅</a>&nbsp;来订阅本博客.(推荐使用&nbsp;<a class="reference external" href="http://reader.google.com/" target="_blank">google reader</a>, 如果你的浏览器不支持直接订阅,请直接在&nbsp;<a class="reference external" href="http://reader.google.com/" target="_blank">google reader</a>&nbsp;中手动添加).</p><p>点击&nbsp;<a class="reference external" href="http://groups.google.com/group/python-share/web/REST%20vs%20RPC.pdf" target="_blank">下载pdf阅读</a>.</p><div class="section" id="id1"><h1><a class="toc-backref" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#id15" style="text-decoration: none; color: black; " target="_blank">摘要</a></h1><p><a class="reference external" href="http://en.wikipedia.org/wiki/Web_Service" target="_blank">Web Service</a>&nbsp;已经不再新鲜, 而随后的&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Service-oriented_architecture" target="_blank">SOA</a>,&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Cloud_computing" target="_blank">Cloud Computing</a>&nbsp;也不断出现, 直到百度也 提出了自己的&nbsp;<a class="reference external" href="http://boxcomputing.baidu.com/" target="_blank">框计算</a>, 我们尚且不管这些时髦的名词背后所蕴藏的实际的技术创新有多少, 但是他们终究是逃不出一点, 即&nbsp;<strong>如何解决访问服务的问题</strong>, 而此处的服务通常不在本地而是在 遥远的你不知道的美国或者印度.</p><p>本文想阐述标题中提到的两种解决远程服务访问的方法,优缺点及其一些实际的建议等.</p><div class="contents topic" id="contents" style="margin-top: 2em; margin-right: 2em; margin-bottom: 2em; margin-left: 2em; "><p class="topic-title first" style="margin-top: 0px !important; font-weight: bold; ">Contents</p><ul class="simple" style="margin-bottom: 1em; "><li><a class="reference internal" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#id1" id="id15" target="_blank">摘要</a></li><li><a class="reference internal" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#id2" id="id16" target="_blank">引入</a></li><li><a class="reference internal" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#web-service" id="id17" target="_blank">Web Service</a></li><li><a class="reference internal" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#rpc" id="id18" target="_blank">RPC</a></li><li><a class="reference internal" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#rest" id="id19" target="_blank">REST</a></li><li><a class="reference internal" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#rpc-rest" id="id20" target="_blank">RPC与REST的区别</a></li><li><a class="reference internal" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#id3" id="id21" target="_blank">如何选择?</a></li><li><a class="reference internal" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#id4" id="id22" target="_blank">一个自己的项目例子</a></li><li><a class="reference internal" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#id5" id="id23" target="_blank">结论</a></li><li><a class="reference internal" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#id6" id="id24" target="_blank">参考资料</a></li><li><a class="reference internal" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#rst" id="id25" target="_blank">本文的rst源码</a></li></ul></div></div><div class="section" id="id2"><h1><a class="toc-backref" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#id16" style="text-decoration: none; color: black; " target="_blank">引入</a></h1><p>我们每天都在使用浏览器来上网冲浪, 在查找自己需要的资源, HTTP协议自然是我们使用的最多的 一种, 我们尽情地享受着这种信息高速路的快感,却没有试图去了解我们是如何获得这些资源的? 它是一种什么样的设计理念?</p><p>我们也偶尔会使用 Gtalk来和自己的同事或者朋友来聊天, 我们在给朋友提供资源(信息)的同时 也获取着朋友的资源(信息), 我们是否可曾想过, 这种交流背后又是一种什么过程呢?</p><p>在这互联网的时代,只要牵扯到获得非本地的资源, 都会面临一个问题:</p><p><strong>如何访问服务呢?</strong></p><p>让我们先看看什么是&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Web_Service" target="_blank">Web Service</a>.</p></div><div class="section" id="web-service"><h1><a class="toc-backref" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#id17" style="text-decoration: none; color: black; " target="_blank">Web Service</a></h1><p><a class="reference external" href="http://en.wikipedia.org/wiki/Web_Service" target="_blank">Web Service</a>&nbsp;也提出了好久了, 那么究竟什么是&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Web_Service" target="_blank">Web Service</a>&nbsp;?</p><p>简单地说, 也就是服务器如何向客户端提供服务.</p><p>常用的方法有:</p><ol class="arabic simple" style="margin-bottom: 1em; list-style-type: decimal; list-style-position: initial; list-style-image: initial; "><li><a class="reference external" href="http://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank">RPC</a>&nbsp;所谓的远程过程调用 (面向方法)</li><li><a class="reference external" href="http://en.wikipedia.org/wiki/Service-oriented_architecture" target="_blank">SOA</a>&nbsp;所谓的面向服务的架构(面向消息)</li><li><a class="reference external" href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank">REST</a>&nbsp;所谓的&nbsp;<strong>Representational state transfer</strong>&nbsp;(面向资源)</li></ol><p><a class="reference external" href="http://en.wikipedia.org/wiki/Service-oriented_architecture" target="_blank">SOA</a>&nbsp;是前几年炒的很火的一个词, 不亚于当前的&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Cloud_computing" target="_blank">Cloud Computing</a>&nbsp;, 如果说&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank">RPC</a>&nbsp;是基于方法调用(method),那么&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Service-oriented_architecture" target="_blank">SOA</a>&nbsp;则是基于&nbsp;<strong>消息</strong>, 基于方法调用通常会与特定的程序语言 耦合起来,而后者则与具体的实现语言无关, 所以在一定程度上得到大公司的支持.</p><p>本文不会在&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Service-oriented_architecture" target="_blank">SOA</a>&nbsp;上着笔过多, 主要是因为笔者本人对这个没有多少研究, 怕误导读者. 另, 笔者 最近对&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank">RPC</a>&nbsp;和&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank">REST</a>&nbsp;方式的原理和实现有一些研究, 所以本文会主要集中在&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank">RPC</a>&nbsp;和<a class="reference external" href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank">REST</a>.</p></div><div class="section" id="rpc"><h1><a class="toc-backref" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#id18" style="text-decoration: none; color: black; " target="_blank">RPC</a></h1><p><a class="reference external" href="http://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank">RPC</a>&nbsp;即远程过程调用, 很简单的概念,&nbsp;<strong>像调用本地服务(方法)一样调用服务器的服务(方法)</strong>.</p><p>通常的实现有&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Xml-rpc" target="_blank">XML-RPC</a>&nbsp;,&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/JSON-RPC" target="_blank">JSON-RPC</a>&nbsp;, 通信方式基本相同, 所不同的只是传输数据的格式.</p><p>(如果你已经习惯于XML繁重的尖括号,你不妨可以尝试下更加轻型,高效,传输效率高的&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Json" target="_blank">JSON</a>.)</p><p>一个简单的通信过程通常为:</p><p>Request</p><div class="highlight"><pre><span style="color: #bc7a00; ">&lt;?xml version="1.0"?&gt;</span>
<span style="color: #008000; font-weight: bold; ">&lt;methodCall&gt;</span>
  <span style="color: #008000; font-weight: bold; ">&lt;methodName&gt;</span>member.get_username_by_id<span style="color: #008000; font-weight: bold; ">&lt;/methodName&gt;</span>
  <span style="color: #008000; font-weight: bold; ">&lt;params&gt;</span>
    <span style="color: #008000; font-weight: bold; ">&lt;param&gt;</span>
        <span style="color: #008000; font-weight: bold; ">&lt;value&gt;&lt;i4&gt;</span>1<span style="color: #008000; font-weight: bold; ">&lt;/i4&gt;&lt;/value&gt;</span>
    <span style="color: #008000; font-weight: bold; ">&lt;/param&gt;</span>
  <span style="color: #008000; font-weight: bold; ">&lt;/params&gt;</span>
<span style="color: #008000; font-weight: bold; ">&lt;/methodCall&gt;</span>
</pre></div><p>Response</p><div class="highlight"><pre><span style="color: #bc7a00; ">&lt;?xml version="1.0"?&gt;</span>
<span style="color: #008000; font-weight: bold; ">&lt;methodResponse&gt;</span>
  <span style="color: #008000; font-weight: bold; ">&lt;params&gt;</span>
    <span style="color: #008000; font-weight: bold; ">&lt;param&gt;</span>
        <span style="color: #008000; font-weight: bold; ">&lt;value&gt;&lt;string&gt;</span>Zhu Tao<span style="color: #008000; font-weight: bold; ">&lt;/string&gt;&lt;/value&gt;</span>
    <span style="color: #008000; font-weight: bold; ">&lt;/param&gt;</span>
  <span style="color: #008000; font-weight: bold; ">&lt;/params&gt;</span>
<span style="color: #008000; font-weight: bold; ">&lt;/methodResponse&gt;</span>
</pre></div><p>向服务器发送一个过程调用的方法及其参数, 得到服务器返回的方法执行的结果.</p><p>在&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Xml-rpc" target="_blank">XML-RPC</a>&nbsp;之后又有了更加强大的&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/SOAP" target="_blank">SOAP</a>&nbsp;, 用于一些比较复杂的系统之上.</p></div><div class="section" id="rest"><h1><a class="toc-backref" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#id19" style="text-decoration: none; color: black; " target="_blank">REST</a></h1><p>终于我们来看&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank">REST</a>&nbsp;了, 呵呵, 这个是我目前比较喜欢的一个远程通信方法(架构).</p><p><a class="reference external" href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank">REST</a>&nbsp;不是一种协议,它是一种架构, 一种&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Web_Service" target="_blank">Web Service</a>&nbsp;能够如果满足&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank">REST</a>&nbsp;的几个条件, 通常就称这个系统是&nbsp;<em>Restful</em>&nbsp;的.</p><p>这里提到的条件包括:</p><ol class="arabic simple" style="margin-bottom: 1em; list-style-type: decimal; list-style-position: initial; list-style-image: initial; "><li>C/S结构 (这是Internet服务的一个基本特征)</li><li>无状态 (很熟悉吧,呵呵)</li><li>可以cache (想起了浏览器?)</li><li>分层系统 (想起了无数的架构?)</li><li>统一的接口 (如果这是可能的,程序员有福了, :D)</li><li>code on demand(可选, 其实是一种扩展性的要求)</li></ol><p>看了这几个特征后,你想起了什么?</p><p>你可能会破口而出:&nbsp;<strong>HTTP</strong>.</p><p>我答:&nbsp;<strong>You got it!</strong></p><p>HTTP是WWW的最核心的协议, 它将简单的分布于世界各个角落的资源都统一起来, 统一的地址, 简单的方法, 和一定数量的表达方式.(你可能对这三点描述很模糊,请go ahead).</p><p><a class="reference external" href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank">REST</a>&nbsp;的三个要素是&nbsp;<strong>唯一的资源标识</strong>,&nbsp;<strong>简单的方法</strong>&nbsp;(此处的方法是个抽象的概念),&nbsp;<strong>一定的表达方式</strong>.</p><p>看下图:</p><img alt="http://farm3.static.flickr.com/2707/4109518844_c77091c2c7.jpg" src="http://farm3.static.flickr.com/2707/4109518844_c77091c2c7.jpg" /><p>图一. REST的三角架构(摘自&nbsp;<a class="reference external" href="http://www.slideshare.net/trilancer/restful-user-experience-1421793" target="_blank">Restful User Experience</a>&nbsp;)</p><p><a class="reference external" href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank">REST</a>&nbsp;是以&nbsp;<strong>资源</strong>&nbsp;为中心, 名词即资源的地址, 动词即施加于名词上的一些有限操作, 表达是对各种资源形态的抽象.</p><p>以HTTP为例, 名词即为URI(统一资源标识), 动词包括POST, GET, PUT, DELETE等(还有其它不常用的2个,所以 整个动词集合是有限的), 资源的形态(如text, html, image, pdf等)</p></div><div class="section" id="rpc-rest"><h1><a class="toc-backref" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#id20" style="text-decoration: none; color: black; " target="_blank">RPC与REST的区别</a></h1><p>如果你想只记住一点,那么就请记住&nbsp;<strong>RPC是以动词为中心的, REST是以名词为中心的</strong>, 此处的 动词指的是一些方法, 名词是指资源.</p><p>你会发现,以动词为中心,意味着,当你要需要加入新功能时,你必须要添加更多的动词, 这时候服务器端需要实现 相应的动词(方法), 客户端需要知道这个新的动词并进行调用.</p><p>而以名词为中心, 假使我请求的是 hostname/friends/, 无论这个URI对应的服务怎么变化,客户端是无需 关注和更新的,而这种变化对客户端也是透明的.</p><p>至于其它的区别,如对实现语言的依赖, 耦合性等,这些都是上面提到的这个根本区别所衍生的.</p><p>让我们回到引入部分的2个问题. 当你每天使用HTTP冲浪时,你都在使用&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank">REST</a>&nbsp;与远程的服务器进行亲密接触. 当你使用Gtalk和同事朋友沟通时,你则是在享受着&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank">RPC</a>&nbsp;的便利.</p><p>推荐阅读&nbsp;<a class="reference external" href="http://www.slideshare.net/trilancer/restful-user-experience-1421793" target="_blank">Restful User Experience</a>&nbsp;(这个slide是个人认为解释的最好的) 还有&nbsp;<a class="reference external" href="http://www.slideshare.net/ozten/rest-vs-soap-yawn" target="_blank">ReST vs SOA(P)</a>.</p></div><div class="section" id="id3"><h1><a class="toc-backref" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#id21" style="text-decoration: none; color: black; " target="_blank">如何选择?</a></h1><p>通常如果我们是客户端,我们基本上是没有选择的权利的, 服务提供商通常只有一种架构的服务.例如facebook, 人人 网开放的API(使用的是&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank">REST</a>&nbsp;).</p><p>但是倘若我们有幸设计和实现自己的&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Web_Service" target="_blank">Web Service</a>&nbsp;我们该如何选择呢?</p><p>根据笔者自己的经验和心得, 建议&nbsp;<strong>能够使用REST就尽量使用REST</strong>, 主要基于下面几个考虑:</p><ol class="arabic simple" style="margin-bottom: 1em; list-style-type: decimal; list-style-position: initial; list-style-image: initial; "><li>扩展性</li><li>松耦合(意味着,不用强制要求客户端去更新相应的代码)</li><li>客户端实现语言无关</li><li>性能</li><li>安全性(例如HTTPS)</li></ol><p>当然上述的几点也并非&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank">RPC</a>&nbsp;都不满足,不过相对而言,&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank">REST</a>&nbsp;更加清晰和简洁, 再辅以&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Json" target="_blank">JSON</a>&nbsp;相应的服务会在性能和稳定性(简单通常意味着robust)方面有很大的提高.</p></div><div class="section" id="id4"><h1><a class="toc-backref" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#id22" style="text-decoration: none; color: black; " target="_blank">一个自己的项目例子</a></h1><p>我们公司正在做一个social game的项目, 我负责整个系统的后端架构和通信等, 所以仔细地学习和研究了 facebook/人人网开放的API, 由于facebook(人人网完全拷贝facebook)使用的是<a class="reference external" href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank">REST</a>&nbsp;的架构, 所以即使facebook本身是PHP开发的,这也不妨碍我们使用python来开发, 还有更多的PHP, Java, .net, Perl等客户端API封装. (当然人人网是使用Java开发的,我们也使用python).</p><p>于是在想,倘若facebook的架构使用的不是&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank">REST</a>&nbsp;,会有这样的灵活性吗? 如果使用的是&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank">RPC</a>&nbsp;可能 目前我们的日子不会好过, 甚至我们的项目都不可能立项!</p><p>另外,因为我们的前端使用的是flash, 与后端的python通信采用的是&nbsp;<a class="reference external" href="http://djangoamf.sourceforge.jp/index.php?DjangoAMF_en" target="_blank">djangoamf</a>&nbsp;, 有意思的是, 如果你了解 flash,你会知道AMF是一种二进制的flash数据交互协议, 而&nbsp;<strong>它是基于RPC</strong>&nbsp;! 当然这正如我上面说的, 某些架构不是我们能够选择的, 所以使用&nbsp;<a class="reference external" href="http://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank">RPC</a>&nbsp;的结果是如果我们想开放我们游戏的API(假如我们的游戏足够火, 有朋友想基于我们的游戏开发周边应用),这就变得很艰难了.但是目前来看,我们开放API的可能性不大.</p></div><div class="section" id="id5"><h1><a class="toc-backref" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#id23" style="text-decoration: none; color: black; " target="_blank">结论</a></h1><p>无论是基于&nbsp;<strong>动词</strong>,&nbsp;<strong>名词</strong>&nbsp;或者&nbsp;<strong>消息</strong>, 这些都是为我们提供一个稳定,可靠,安全,易扩展的服务为目的的, 所以,如果你有机会为别的客户端提供开放API(如果你们公司是另一个facebook, twitter),你不妨多考虑下基于 你的平台的开发者们, 别让他们的日子不好过啊(同是程序员,相煎何太急?呵呵).</p><p>欢迎交流.</p></div><div class="section" id="id6"><h1><a class="toc-backref" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#id24" style="text-decoration: none; color: black; " target="_blank">参考资料</a></h1><ol class="arabic simple" style="margin-bottom: 1em; list-style-type: decimal; list-style-position: initial; list-style-image: initial; "><li><a class="reference external" href="http://en.wikipedia.org/wiki/Web_Service" target="_blank">Web Service</a></li><li><a class="reference external" href="http://en.wikipedia.org/wiki/Service-oriented_architecture" target="_blank">SOA</a></li><li><a class="reference external" href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank">REST</a></li><li><a class="reference external" href="http://en.wikipedia.org/wiki/Remote_procedure_call" target="_blank">RPC</a></li><li><a class="reference external" href="http://en.wikipedia.org/wiki/Cloud_computing" target="_blank">Cloud Computing</a></li><li><a class="reference external" href="http://boxcomputing.baidu.com/" target="_blank">框计算</a></li><li><a class="reference external" href="http://www.slideshare.net/ozten/rest-vs-soap-yawn" target="_blank">ReST vs SOA(P)</a></li><li><a class="reference external" href="http://www.slideshare.net/trilancer/restful-user-experience-1421793" target="_blank">Restful User Experience</a></li></ol></div><div class="section" id="rst"><h1><a class="toc-backref" href="file:///E:/hg/knowledge/blog-zh/source/web-development/zhutao.html#id25" style="text-decoration: none; color: black; " target="_blank">本文的rst源码</a></h1><p>本文的源码链接在&nbsp;<a class="reference external" href="http://groups.google.com/group/python-share/web/REST_vs_RPC.rst" target="_blank">这里</a>&nbsp;.</p><p>点击&nbsp;<a class="reference external" href="http://groups.google.com/group/python-share/web/REST%20vs%20RPC.pdf" target="_blank">下载pdf阅读</a>.</p></div></span>
